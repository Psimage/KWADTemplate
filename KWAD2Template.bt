//--------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File:
// Author: YAROSBUG
// Revision:
// Purpose:

// Notes:

// ResourceInfo.location -> Resource
// TexResource.index -> Names[i]
// Names.index -> ResourceInfo[i]
// ResourceInfo[Names.index] -> Resource
// ResourceInfo[Names[TexResource.index]] -> NewResource - "TexResource" is a part of "NewResource"

// MDL1
// anims.kwad
// res info 5057 - location 1A6A230h
// res name 6744 - name "anims/Final_room/finalroom_1x1_centerconsole1.anim/keyboard_fx_b-27.mdl"

// ADEF -> KLEIANM1 -> animation definition -> animation.xml
// ABLD -> KLEIBLD1 -> animation build -> build.xml
// MDL maps to KLEIMDL1
// PNG maps to KLEITEX1
// TEX maps to KLEISRF1
//--------------------------------------

#define SIG_KLEI_SURFACE    "KLEISRF1" // defined as TEX in NamesList
#define SIG_KLEI_TEXTURE    "KLEITEX1" // defined as PNG in NamesList
#define SIG_KLEI_BLOB       "KLEIBLOB" // data as is
#define SIG_KLEI_ANIMATION  "KLEIANM1"
#define SIG_KLEI_MODEL      "KLEIMDL1"
#define SIG_KLEI_BUILD      "KLEIBLD1" // has .fla file names in it (related to Adobe Flash .fla files)

//USAffine3D ---------------------------------------------------------
typedef struct { //USAffine3D in Moai framework
    float c0[3]; //4 cols, 3 rows
    float c1[3];
    float c2[3];
    float c3[3];
} USAffine3D;
//---------------------------------------------------------------------

//ResourceInfo -------------------------------------------------------
typedef struct {
    int32 slabIndex<format=hex>; // = 0 in 100%
    int32 size<format=hex>;
    int32 location<format=hex>; // increases with item index (position). Always greater then prev item value
    char type[4]<open=suppress>;
} ResourceInfo<read=ResourceInfo_Read>;

string ResourceInfo_Read(ResourceInfo &info) {
    local string result;
    SPrintf(result, "%s", info.type);
    return result;
};
//---------------------------------------------------------------------

//ResourceName -------------------------------------------------------
typedef struct {
    int32 nameLength <hidden=true>;
    char name[nameLength]<open=suppress>;
    if((nameLength & 3) != 0) { //4 bytes aligned
        byte padding[4 - (nameLength & 3)] <hidden=true>;
    }
    int32 RI_index; //ResourceInfo[index] to this ResourceName
} ResourceName<read=ResourceName_Read, size=ResourceName_Size>;

string ResourceName_Read(ResourceName &resourceName) {
    return resourceName.name;
};

int ResourceName_Size(ResourceName &resourceName) {
    local int32 textLen = ReadUInt(startof(resourceName));
    local int32 padding = (4 - (textLen & 3)) & 3;
    return textLen + padding + 8;
};
//---------------------------------------------------------------------

//KLEI_Surface --------------------------------------------------------
typedef struct {
    //overall header size is 2C
    byte signature[8]<open=suppress>; //KLEISRF1
    int32 size <format=hex>; //including signature and this field (in bytes)
    int32 openglType<format=hex>; //0x83F3 = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, 0x1908 = GL_RGBA
    int32 openglStorageType<format=hex>; //0x8058 = GL_RGBA8_OES, 0x83F3 = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    int32 isDXTCompressed; //DXT5
    int32 mipCount;
    int32 totalSizeOfAllMips<format=hex>;
    struct MipLevel {
        int32 size <format=hex>;
        int32 width;
        int32 height;
        int32 compressedSize <format=hex>;
        byte compressedData[compressedSize] <format=hex, open=suppress>; //zlib stream
    } mipLevel[mipCount]<optimize=false>;
} KLEI_SRF<size=KLEI_SRF_Size>; 

int KLEI_SRF_Size(KLEI_SRF &srf) {
    return ReadUInt(startof(srf)+8);
} 
//---------------------------------------------------------------------

//KLEI_Texture --------------------------------------------------------
typedef struct {
    //overall header size is 30h
    byte signature[8]<open=suppress>; //KLEITEX1
    int32 size <format=hex>; //including signature and this field (in bytes)
    int32 index;    //index in resourceInfoList (probably should point to surface type resource only)
    int32 widthPx;  //in pixels
    int32 heightPx;
    struct Affine2D {
        float scaleX;    //ralative to the size of surface in which it resides (value from 0 to 1)
        float x2y1;
        float x1y2;
        float scaleY;
        float translateX; // ralative to the size of surface in which it resides (value from 0 to 1)
        float translateY; // ralative to the size of surface in which it resides (value from 0 to 1)
    } affine2d;
} KLEI_TEX<size=KLEI_TEX_Size, read=KLEI_TEX_Read>; 

int KLEI_TEX_Size(KLEI_TEX &tex) {
    return ReadUInt(startof(tex)+8);
} 

string KLEI_TEX_Read(KLEI_TEX &tex) {
    local string result;
    SPrintf(result, "%d", tex.index);
    return result;
};
//------------------------------------------------------------------

//KLEI_Blob --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEIBLOB
    int32 dataSize <format=hex>;
    byte data[dataSize]<open=suppress>;
} KLEI_BLOB<size=KLEI_BLOB_Size>; 

int KLEI_BLOB_Size(KLEI_BLOB &blob) {
    return ReadUInt(startof(blob)+8)+12;
} 
//---------------------------------------------------------------------

//KLEI_MODEL --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEIMDL1
    int32 structSize <format=hex>; //including signature and this field (in bytes)
    int32 index<format=decimal>;
    byte _q_signature[4]<format=hex, open=suppress>;
    int32 _q_indices[9];
    struct VertexArray {
        struct VertexAttributes {
            struct Position {
                float x;
                float y;
            } position;
            struct TexCoord {
                float u;
                float v;
            } texCoord;
        } vertexAttributes;
    } vertexArray[4];
} KLEI_MDL<size=KLEI_MDL_Size>; 

int KLEI_MDL_Size(KLEI_MDL &model) {
    return ReadUInt(startof(model)+8);
} 
//---------------------------------------------------------------------

//KLEI_AMINATION --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress, bgcolor=0xF4A903>; //KLEIANM1
    int32 structSize <format=hex>; //including signature and this field (in bytes)
    
    int32 animCount<hidden=true>;
    struct Animation {
        int32 nameHash<format=hex>;
        char name[20]<open=suppress>;
        int32 rootSymbolHash<format=hex>;
        float frameRate;
        int32 facingMask<format=hex>;   //16 - West, 64 - South, 4 - North, 1 - East
                                        //?S?W?N?E
        int32 frameIndex;
        int32 frameCount;
    } anims[animCount]<read=Animation_Read>;

    int32 frameCount<hidden=true>;
    struct Frame {
	    int32 eventIdx;
	    int32 eventCount;
	    int32 instanceIdx;
	    int32 instanceCount;
    } frames[frameCount];
    int32 __padding__<hidden=true>;

    int32 instanceCount<hidden=true>;
    struct Instance {
        int32 symbolHash<format=hex>;
        int32 folderHash<format=hex>;
        int32 parentHash<format=hex>;
        int32 symbolFrame;
        int32 parentTransformIdx;
        int32 transformIdx;
        int32 CMIdx;
        int32 CAIdx;
    } instances[instanceCount];

    int32 colourCount<hidden=true>;
    struct Colour { //USColorVec in Moai framework
        float r;
        float g;
        float b;
        float a;
    } colours[colourCount];

    int32 transformCount<hidden=true>;
    USAffine3D transforms[transformCount];
    int32 ___padding___<hidden=true>;

} KLEI_ANM<size=KLEI_ANM_Size, bgcolor=0xFEF5E1>; 

int KLEI_ANM_Size(KLEI_ANM &animation) {
    return ReadUInt(startof(animation)+8);
} 

string Animation_Read(Animation &animation) {
    local string result;   
    SPrintf(result, "%s", animation.name);
    return result;
} 
//---------------------------------------------------------------------

//KLEI_BUILD --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEIBLD1
    int32 structSize <format=hex>; //including signature and this field (in bytes)

    int32 nameLength<hidden=true>;
    char name[nameLength]<open=suppress>;
    if((nameLength & 3) != 0) { //4 bytes aligned
        byte padding[4 - (nameLength & 3)] <hidden=true>;
    }

    int32 symbolsCount<hidden=true>;
    struct Symbol {
        int32 hash<format=hex>;
        char name[20];
        int32 frameIdx;
        int32 frameCount;
    } symbols[symbolsCount]<read=Symbol_Read>;

    int32 symbolFrameCount<hidden=true>;
    struct SymbolFrame {
        int32 modelIdx;
        USAffine3D transform;
    } symbolFrames[symbolFrameCount];

} KLEI_BLD<size=KLEI_BLD_Size, read=KLEI_BLD_Read>; 

int KLEI_BLD_Size(KLEI_BLD &build) {
    return ReadUInt(startof(build)+8);
} 

string KLEI_BLD_Read(KLEI_BLD &build) {
    return build.name;
} 

string Symbol_Read(Symbol &symbol) {
    return symbol.name;
} 
//---------------------------------------------------------------------

//ResourceInfoList ----------------------------------------------------
typedef struct {
    int32 itemsCount <hidden=true>;
    ResourceInfo items[itemsCount];    
} ResourceInfoList<read=ResourceInfoList_Read>;

string ResourceInfoList_Read(ResourceInfoList &unk_struct1_array) {
    local string result;   
    SPrintf(result, "%d", unk_struct1_array.itemsCount);
    return result;
};
//---------------------------------------------------------------------

//ResourceNameList ----------------------------------------------------
typedef struct {
    int32 itemsCount <hidden=true>;
    ResourceName items[itemsCount] <optimize=false>;    
} ResourceNameList<read=ResourceNameList_Read>;

string ResourceNameList_Read(ResourceNameList &unk_struct2_array) {
    local string result;   
    SPrintf(result, "%d", unk_struct2_array.itemsCount);
    return result;
};
//---------------------------------------------------------------------

//ResourceList -----------------------------------------------------
typedef struct (ResourceInfoList &ril, string resSig) {
    local int32 resCount;
    local int32 i;
    local int32 offset;
    local char sig[9];
    local string type = resSig;

    for (i = 0; i < ril.itemsCount; i++) {
        offset = ril.items[i].location;
        FSeek(offset);
    
        ReadBytes(sig, FTell(), 8);
    
        if(sig == resSig) {
            FSeek(offset);
            if(sig == SIG_KLEI_MODEL) {
                KLEI_MDL model;
            } else if(sig == SIG_KLEI_BLOB) {
                KLEI_BLOB blob;
            } else if(sig == SIG_KLEI_SURFACE) {
                KLEI_SRF surface;
            } else if(sig == SIG_KLEI_TEXTURE) {
                KLEI_TEX texture;
            } else if(sig == SIG_KLEI_ANIMATION) {
                KLEI_ANM animation;
            } else if(sig == SIG_KLEI_BUILD) {
                KLEI_BLD build;
            }
            resCount++;
        }
    } 
} ResourceList<read=ResourceList_Read>;

string ResourceList_Read(ResourceList &resList) {
    local string result;   
    SPrintf(result, "%s [%d]", resList.type, resList.resCount);
    return result;
};
//-------------------------------------------------------------------

// Main

RequiresVersion(5, 0, 0);
LittleEndian();

Printf("Start time: %s\n", GetCurrentTime("hh:mm:ss"));

byte signature[8]<open=suppress>;
int32 fileSize;
int32 slabCount;

ResourceInfoList resourceInfoList;
ResourceNameList resourceNameList;

ResourceList surfaceList(resourceInfoList, SIG_KLEI_SURFACE);
FSeek(0); //Workaround
ResourceList textureList(resourceInfoList, SIG_KLEI_TEXTURE);
FSeek(0); //Workaround
ResourceList blobList(resourceInfoList, SIG_KLEI_BLOB);
FSeek(0); //Workaround
ResourceList modelList(resourceInfoList, SIG_KLEI_MODEL);
FSeek(0); //Workaround
ResourceList animationList(resourceInfoList, SIG_KLEI_ANIMATION);
FSeek(0); //Workaround
ResourceList buildList(resourceInfoList, SIG_KLEI_BUILD);

Printf("End time: %s\n", GetCurrentTime("hh:mm:ss"));