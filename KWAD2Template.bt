//--------------------------------------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// Author: Psimage
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//--- Notes
//
// ADEF -> KLEIANM1 -> animation definition -> animation.xml
// ABLD -> KLEIBLD1 -> animation build      -> build.xml
// MDL  -> KLEIMDL1 -> Model (Vertex Buffer)
// PNG  -> KLEITEX1 -> Sub-image/Sprite (only "meta", image is in SRF)
// TEX  -> KLEISRF1 -> Texture Atlas/Sprite sheet
//--------------------------------------------------------------------

#define SIG_KLEI_SURFACE    "KLEISRF1" // .tex
#define SIG_KLEI_TEXTURE    "KLEITEX1" // .png
#define SIG_KLEI_BLOB       "KLEIBLOB" // data as is
#define SIG_KLEI_ANIMATION  "KLEIANM1" // .adef
#define SIG_KLEI_MODEL      "KLEIMDL1" // .mdl
#define SIG_KLEI_BUILD      "KLEIBLD1" // .abld

//USAffine3D ---------------------------------------------------------
typedef struct { //USAffine3D in Moai framework
    float c0[3]; //4 cols, 3 rows Matrix
    float c1[3];
    float c2[3];
    float c3[3];
} USAffine3D;
//--------------------------------------------------------------------

//ResourceInfo -------------------------------------------------------
typedef struct {
    int32 slabIdx<format=hex>;
    int32 size<format=hex>;
    int32 offset<format=hex>;       //From the beginning of the file to the resource
    byte type[4]<open=suppress>;    //of this field type (should "logically" match with a signature)
} ResourceInfo<read=ResourceInfo_Read>;

string ResourceInfo_Read(ResourceInfo &info) {
    return info.type;
};
//---------------------------------------------------------------------

//AliasInfo -----------------------------------------------------------
typedef struct {
    int32 aliasPathLength <hidden=true>;
    char aliasPath[aliasPathLength]<open=suppress>;

    if((aliasPathLength & 3) != 0) { //4 bytes aligned
        byte padding[4 - (aliasPathLength & 3)] <hidden=true>;
    }

    int32 resourceIdx; //Index into ResourceInfoList
} AliasInfo<read=AliasInfo_Read, size=AliasInfo_Size>;

string AliasInfo_Read(AliasInfo &aliasInfo) {
    return aliasInfo.aliasPath;
};

int AliasInfo_Size(AliasInfo &aliasInfo) {
    local int32 textLen = ReadUInt(startof(aliasInfo));
    local int32 padding = (4 - (textLen & 3)) & 3;
    return textLen + padding + 8;
};
//---------------------------------------------------------------------

//KLEI_Surface --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEISRF1
    int32 structSize <format=hex>; //including signature and this field (in bytes)

    int32 openglType<format=hex>; //0x83F3 = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, 0x1908 = GL_RGBA
    int32 openglStorageType<format=hex>; //0x8058 = GL_RGBA8_OES, 0x83F3 = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT

    int32 isDXTCompressed; //DXT5/BC3 Boolean

    int32 mipmapCount;
    int32 totalSizeOfAllMips<format=hex>;
    struct MipmapLevel {
        int32 size <format=hex>;
        int32 widthPx; //in pixels
        int32 heightPx;
        int32 compressedSize <format=hex>;
        byte compressedData[compressedSize] <format=hex, open=suppress>; //zlib stream
    } mipmap[mipmapCount]<optimize=false>;
} KLEI_SRF<size=KLEI_SRF_Size>; 

int KLEI_SRF_Size(KLEI_SRF &srf) {
    return ReadUInt(startof(srf)+8);
} 
//---------------------------------------------------------------------

//KLEI_Texture --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEITEX1
    int32 structSize <format=hex>; //including signature and this field (in bytes)

    int32 parentSurfaceResourceIdx; //index into ResourceInfoList. Probably should point to surface type (KLEISRF) resource only
    
    int32 widthPx; //in pixels
    int32 heightPx;

    struct Affine2D {
        float scaleX; //ralative to the size of surface in which it resides (value from 0 to 1)
        float c2r1; //column/row
        float c1r2;
        float scaleY;
        float translateX; // ralative to the size of surface in which it resides (value from 0 to 1)
        float translateY; // ralative to the size of surface in which it resides (value from 0 to 1)
    } affine2d;
} KLEI_TEX<size=KLEI_TEX_Size, read=KLEI_TEX_Read>; 

int KLEI_TEX_Size(KLEI_TEX &tex) {
    return ReadUInt(startof(tex)+8);
} 

string KLEI_TEX_Read(KLEI_TEX &tex) {
    local string result;
    SPrintf(result, "%d", tex.parentSurfaceResourceIdx);
    return result;
};
//------------------------------------------------------------------

//KLEI_Blob --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEIBLOB
    int32 dataSize <format=hex>;
    byte data[dataSize]<open=suppress>;
} KLEI_BLOB<size=KLEI_BLOB_Size>; 

int KLEI_BLOB_Size(KLEI_BLOB &blob) {
    return ReadUInt(startof(blob)+8)+12;
} 
//---------------------------------------------------------------------

//KLEI_MODEL --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEIMDL1
    int32 structSize <format=hex>; //including signature and this field (in bytes)

    int32 textureResourceIdx; //index into ResourceInfoList. Probably should point to texture type (KLEITEX) resource only
    
    byte _q_signature[4]<format=hex, open=suppress>; //TODO: clarification
    int32 _q_indices[9]; //TODO: clarification

    struct VertexArray {
        struct VertexAttributes {
            struct Position {
                float x;
                float y;
            } position;
            struct TexCoord {
                float u;
                float v;
            } texCoord;
        } vertexAttributes;
    } vertexArray[4];
} KLEI_MDL<size=KLEI_MDL_Size, read=KLEI_MDL_Read>; 

int KLEI_MDL_Size(KLEI_MDL &model) {
    return ReadUInt(startof(model)+8);
} 

string KLEI_MDL_Read(KLEI_MDL &model) {
    local string result;
    SPrintf(result, "%d", model.textureResourceIdx);
    return result;
} 
//---------------------------------------------------------------------

//KLEI_AMINATION --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress, bgcolor=0xF4A903>; //KLEIANM1
    int32 structSize <format=hex>; //including signature and this field (in bytes)
    
    int32 animCount<hidden=true>;
    struct Animation {
        int32 nameHash<format=hex>;
        char name[20]<open=suppress>;
        int32 rootSymbolHash<format=hex>;
        float frameRate;
        int32 facingMask<format=hex>;   //64(40h) - South, 16(10h) - West, 4(4h) - North, 1(1h) - East
                                        //FFFFFFFF(-1) - Mask was not specified 
                                        //EBNF: animation name = name,[_{(S|W|N|E)_}]
                                        //Example: idle_S_N_
        int32 frameIdx;
        int32 frameCount;
    } anims[animCount]<read=Animation_Read>;

    int32 frameCount<hidden=true>;
    struct Frame {
	    int32 eventIdx;
	    int32 eventCount;
	    int32 instanceIdx;
	    int32 instanceCount;
    } frames[frameCount];
    int32 __padding__<hidden=true>;

    int32 instanceCount<hidden=true>;
    struct Instance {
        int32 symbolHash<format=hex>;
        int32 folderHash<format=hex>;
        int32 parentHash<format=hex>;
        int32 symbolFrame;
        int32 parentTransformIdx;
        int32 transformIdx;
        int32 CMIdx; //TODO: clarification
        int32 CAIdx; //TODO: clarification
    } instances[instanceCount];

    int32 colourCount<hidden=true>;
    struct Colour { //USColorVec in Moai framework
        float r;
        float g;
        float b;
        float a;
    } colours[colourCount];

    int32 transformCount<hidden=true>;
    USAffine3D transforms[transformCount];
    int32 ___padding___<hidden=true>;

} KLEI_ANM<size=KLEI_ANM_Size, bgcolor=0xFEF5E1>; 

int KLEI_ANM_Size(KLEI_ANM &animation) {
    return ReadUInt(startof(animation)+8);
} 

string Animation_Read(Animation &animation) {
    local string result;   
    SPrintf(result, "%s", animation.name);
    return result;
} 
//---------------------------------------------------------------------

//KLEI_BUILD --------------------------------------------------------
typedef struct {
    byte signature[8]<open=suppress>; //KLEIBLD1
    int32 structSize <format=hex>; //including signature and this field (in bytes)

    int32 nameLength<hidden=true>;
    char name[nameLength]<open=suppress>;
    if((nameLength & 3) != 0) { //4 bytes aligned
        byte padding[4 - (nameLength & 3)] <hidden=true>;
    }

    int32 symbolsCount<hidden=true>;
    struct Symbol {
        int32 hash<format=hex>;
        char name[20];
        int32 frameIdx;
        int32 frameCount;
    } symbols[symbolsCount]<read=Symbol_Read>;

    int32 symbolFrameCount<hidden=true>;
    struct SymbolFrame {
        int32 modelResourceIdx; //index into ResourceInfoList. Probably should point to model type (KLEIMDL) resource only
        USAffine3D transform;
    } frames[symbolFrameCount];

} KLEI_BLD<size=KLEI_BLD_Size, read=KLEI_BLD_Read>; 

int KLEI_BLD_Size(KLEI_BLD &build) {
    return ReadUInt(startof(build)+8);
} 

string KLEI_BLD_Read(KLEI_BLD &build) {
    return build.name;
} 

string Symbol_Read(Symbol &symbol) {
    return symbol.name;
} 
//---------------------------------------------------------------------

//ResourceInfoList ----------------------------------------------------
typedef struct {
    int32 itemsCount <hidden=true>;
    ResourceInfo items[itemsCount];    
} ResourceInfoList<read=ResourceInfoList_Read>;

string ResourceInfoList_Read(ResourceInfoList &unk_struct1_array) {
    local string result;   
    SPrintf(result, "%d", unk_struct1_array.itemsCount);
    return result;
};
//---------------------------------------------------------------------

//AliasInfoList ----------------------------------------------------
typedef struct {
    int32 itemsCount <hidden=true>;
    AliasInfo items[itemsCount] <optimize=false>;    
} AliasInfoList<read=AliasInfoList_Read>;

string AliasInfoList_Read(AliasInfoList &aliasInfoList) {
    local string result;   
    SPrintf(result, "%d", aliasInfoList.itemsCount);
    return result;
};
//---------------------------------------------------------------------

//ResourceList -----------------------------------------------------
typedef struct (ResourceInfoList &ril, string resSig) {
    local int32 resCount;
    local int32 i;
    local int32 offset;
    local char sig[9];
    local string type = resSig;

    for (i = 0; i < ril.itemsCount; i++) {
        offset = ril.items[i].offset;
        FSeek(offset);
    
        ReadBytes(sig, FTell(), 8);
    
        if(sig == resSig) {
            FSeek(offset);
            if(sig == SIG_KLEI_MODEL) {
                KLEI_MDL model;
            } else if(sig == SIG_KLEI_BLOB) {
                KLEI_BLOB blob;
            } else if(sig == SIG_KLEI_SURFACE) {
                KLEI_SRF surface;
            } else if(sig == SIG_KLEI_TEXTURE) {
                KLEI_TEX texture;
            } else if(sig == SIG_KLEI_ANIMATION) {
                KLEI_ANM animation;
            } else if(sig == SIG_KLEI_BUILD) {
                KLEI_BLD build;
            } else {
            }
            resCount++;
        }
    } 
} ResourceList<read=ResourceList_Read>;

string ResourceList_Read(ResourceList &resList) {
    local string result;   
    SPrintf(result, "%s [%d]", resList.type, resList.resCount);
    return result;
};
//-------------------------------------------------------------------

//-------------------------------------------------------------------
// Main

RequiresVersion(5, 0, 0);
LittleEndian();

Printf("Start time: %s\n", GetCurrentTime("hh:mm:ss"));

struct Header {
    byte signature[8]<open=suppress>;
    int32 fileSize;
    int32 slabCount;
    
    ResourceInfoList resourceInfoList;
    AliasInfoList aliasInfoList;
} header;

ResourceList surfaceList(header.resourceInfoList, SIG_KLEI_SURFACE);
FSeek(0); //Workaround
ResourceList textureList(header.resourceInfoList, SIG_KLEI_TEXTURE);
FSeek(0); //Workaround
ResourceList blobList(header.resourceInfoList, SIG_KLEI_BLOB);
FSeek(0); //Workaround
ResourceList modelList(header.resourceInfoList, SIG_KLEI_MODEL);
FSeek(0); //Workaround
ResourceList animationList(header.resourceInfoList, SIG_KLEI_ANIMATION);
FSeek(0); //Workaround
ResourceList buildList(header.resourceInfoList, SIG_KLEI_BUILD);

Printf("End time: %s\n", GetCurrentTime("hh:mm:ss"));